# Linux中的汇编语言
> Linux源码中出现的汇编代码可以分为两种，一种是以.S为扩展名的汇编文件中，整个程序全部由汇编语言组成;另一种是有些汇编命令，会出现在c文件中，在这种文件中，既有c语言又有汇编语言，这种汇编语言称为`嵌入式汇编`，下面我们将对Linux中的汇编语言进行讨论.
## 1.AT&T和Intel汇编语言的比较
> 当`UNIX`被移植到`i386`时，采用了`AT&T`的汇编语言格式，下面我们将比对这两种语法的格式
### 1.1前缀
在Intel语法中，寄存器和立即数都没有前缀，但在`AT&T`中，寄存器冠以"%"前缀，而立即数冠以"$"前缀；在`Intel`语法中，十六进制和二进制立即数后缀为"h"和"b"，在`AT&T`中,十六进制立即数前冠以"0x"
### 1.2操作数方向
两者的操作数方向刚好相反
在`Intel`语法中，第一个操作数是目的操作数，第二个操作数是源操作数;而在`AT&T`中，第一个数是源操作数，第二个数是目的操作数
### 1.3内存单元操作数
在`Intel`语法中，基寄存器用"[]"括起来，而在`AT&T`中，用"()"括起来
### 1.4间接寻址方式
`Intel`的指令格式为$segreg:[base+index*scale+disp]$,而`AT&T`的格式为$segreg:disp(base,index,scale)$,如下给出两种方式间接寻址的例子:

|Intel语法|AT&T语法
|:---|:----|
|foo,segreg:[base+index*scale+disp]|%segreg:disp(base,index,scale),foo
|mov  eax,[ebx+20h]|0x20(%ebx),%eax
|add eax,[ebx+ecx*2h]| Addl (%ebx,%ecx,0x2),%eax
|sub eax,[ebx+ecx*4h-20h]| Subl -0x20(%ebx,%ecx,0x4),%eax

这种寻址方式从定义上就可以看出，用于访问数组某个特定元素内的一个字段，其中base为数组的起始地址，`scale`为每个数组元素的大小，`index`为下标，如果数组元素还是一个结构，则`disp`为具体字段在结构中的位移部分
