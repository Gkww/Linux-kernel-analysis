# Linux硬件基础
了解`Linux`内核，首先要认识到操作系统和一般软件的不同，操作系统是一种充分挖掘硬件潜能的软件，因此要想深入解析操作系统内在的运作机制，就必须搞清楚相关的硬件机制。
Linux 把与硬件相关的代码全部放在 arch目录下，在这个目录下，有 arm、alpha,i386、m68k、mips 等十多种，在这众多的平台中，大家熟悉的就是 i386，即 Inte l80386。
因此，我们所介绍的硬件基础也是以此为背景的。
# i386寄存器
## 通用寄存器
8 个通用寄存器是 8086 寄存器的超集，它们的名称和用途分别为：
* EAX：一般用作累加器。 
* EBX：一般用作基址寄存器（Base）。 
* ECX：一般用来计数（Count）。 
* EDX：一般用来存放数据（Data）。 
* EBP：一般用作堆栈指针（Stack Pointer）。 
* EBP：一般用作基址指针（Base Pointer）。 
* ESI：一般用作源变址（Source Index）。 
* EDI：一般用作目标变址（Destinatin Index）。 
> 这 8 个通用寄存器既可以支持 1 位、8 位、16 位和 32 位数据运算，也支持 16 位和 32 位存储
器寻址。 
## 段寄存器
8086 中有 4 个 16 位的段寄存器：CS、DS、SS、ES，分别用于存放可执行代码的代码段、数据段、堆栈段和其他段的基地址
> CS：代码段寄存器。 
> DS：数据段寄存器。 
> SS：堆栈段寄存器。 
> ES、FS 及 GS：附加数据段寄存器。
## 状态和控制寄存器
### 指令指针寄存器和标志寄存器
* 指令指针寄存器（EIP）中存放下一条将要执行指令的偏移量，这个偏移量是相对于目前正在运行的代码段寄存（CS）而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址
* 标志寄存器定义图

![i386标志寄存器](images/1.png)
...([其他的寄存器链接如下](https://blog.csdn.net/weixin_45611297/article/details/124284991))
## 内存地址
在计算机内，都存在一个程序能产生的内存地址的集合，当程序执行如下指令:
`MOVE REG,ADDR`,它把地址为 ADDR（假设为 10000）的内存单元的内容复制到 REG 中，地址 ADDR 可以通过索引、基址寄存器、段寄存器和其他方式产生。
在 8086 的实模式下，把某一段寄存器左移 4 位，然后与地址 ADDR 相加后被直接送到内
存总线上，这个相加后的地址就是内存单元的物理地址，而程序中的这个地址就叫逻辑地址，在 80386 的保护模式下，这个逻辑地址不是被直接送到内存总线，而是被送到内存管理单元（MMU）,`MMU` 由一个或一组芯片组成，其功能是把逻辑地址映射为物理地址，即进行地址转换，如图所示。
![MMU的位置和功能](images/2.png)
80386的三种不同的地址:
* 逻辑地址
* 线性地址
* 物理地址
> MMU把逻辑地址转换为物理地址的过程
![MMU转化过程](images/3.png)
## 描述符概念
所谓描述符（Descriptor），就是描述段的属性的一个 8 字节存储单元。在实模式下，段的属性不外乎是代码段、堆栈段、数据段、段的起始地址、段的长度等，而在保护模式下则复杂一些。80386 将它们结合在一起用一个 8 字节的数表示，称为描述符
* 用户段描述符如下:
![用户段描述符](images/4.png)
## 描述符表
> 各种各样的用户描述符和系统描述符，都放在对应的全局描述符表、局部描述符表和中断描述符表中，描述符表（即段表）定义了 386 系统的所有段的情况。所有的描述符表本身都占据一个字节为 8 的倍数的存储器空间，

1.全局描述符表(GDT)

2.中断描述符表(IDT)

3.局部描述符(LDT)

* Linux下段机制的寻址过程:
![段机制](images/5.png)

* 描述符投影寄存器:投影寄存器容纳有相应段寄存器寻址的段的基地址、界限及属性。每当用选择符装入段寄存器时，CPU 硬件便自动地把描述符的全部内容装入对应的投影寄存器
## Linux中段代码分析
1.首先，Linux在启动的过程中设置了段寄存器的值和全局描述符GDT的内容，其中段的定义在`include/asm-i386/segment.h`中，具体代码如下
``` c
#define __KERNEL_CS0x10 ／＊内核代码段，index=2,TI=0,RPL=0＊／ 
#define __KERNEL_DS0x18 ／＊内核数据段, index=3,TI=0,RPL=0＊／ 
#define __USER_CS 0x23 ／＊用户代码段, index=4,TI=0,RPL=3＊／ 
#define __USER_DS 0x2B ／＊用户数据段, index=5,TI=0,RPL=3＊／ 

```
可以看出，没有定义堆栈段，是因为Linux不区分堆栈段和数据段，因为没有使用LDT，因此TI=0，内核代码段和数据段具有最高特权，因此其 `RPL`为 0，而用户代码段和数据段具有最低特权，因此其 `RPL` 为 3

全局描述符的定义在`arch/i386/kernel/head.S`中
```armasm
ENTRY（gdt_table） 
 .quad 0x0000000000000000 /* NULL descriptor */ 
 .quad 0x0000000000000000 /* not used */ 
 .quad 0x00cf9a000000ffff /* 0x10 kernel 4GB code at 0x00000000 */ 
 .quad 0x00cf92000000ffff /* 0x18 kernel 4GB data at 0x00000000 */ 
 .quad 0x00cffa000000ffff /* 0x23 user 4GB code at 0x00000000 */ 
 .quad 0x00cff2000000ffff /* 0x2b user 4GB data at 0x00000000 */ 
 .quad 0x0000000000000000 /* not used */ 
 .quad 0x0000000000000000 /* not used */ 
 /* 
 * The APM segments have byte granularity and their bases 
 * and limits are set at run time. 
 */ 
 .quad 0x0040920000000000 /* 0x40 APM set up for bad BIOS's */ 
 .quad 0x00409a0000000000 /* 0x48 APM CS code */ 
 .quad 0x00009a0000000000 /* 0x50 APM CS 16 code （16 bit） */ 
 .quad 0x0040920000000000 /* 0x58 APM DS data */ 
 .fill NR_CPUS*4,8,0 /* space for TSS's and LDT's */ 
```
从代码可以看出，GDT 放在数组变量 gdt_table 中。按 Intel 规定，GDT 中的第一项为空，这是为了防止加电后段寄存器未经初始化就进入保护模式而使用 GDT 的。第二项也没用。从下标 2～5 共 4 项对应于前面的 4 种段描述符值,从描述符的数值可以得出:
(将16进制转为2进制后与描述符具体位进行比对)
* 段的基地址全部为 0x00000000； 
* 段的上限全部为 0xffff； 
* 段的粒度 G 为 1，即段长单位为 4KB； 
* 段的 D 位为 1，即对这 4 个段的访问都为 32 位指令； 
* 段的 P 位为 1，即 4 个段都在内存。 
