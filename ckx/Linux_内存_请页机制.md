# 请页机制
Linux采用请页机制节约内存，它只把当前正在执行的程序要使用的虚拟页（少量一部分）装入内存。当需要未装入的虚拟内存区域时，处理器将向Linux报告一个页故障以及故障原因。
## 页故障的产生
有三种原因：
* 程序出现错误，导致虚拟地址无效，Linux向进程发送SIGSEGV信号并终止进程的运行。
* 虚拟地址有效，但其对应的页并不在物理内存中。这时操作系统从磁盘映像或交换文件中将其装入物理内存。
* 要访问的虚地址被写保护。这时操作系统需要判断：如果是用户进程正在写当前进程的地址空间，则发SIGSEGV信号并终止进程的运行；如果错误在一旧的共享页上，则对该共享页进行复制，即写时复刻（COW）技术。

## 页错误的定位
页错误的定位既包含虚拟地址的定位，也包含被调入页在交换文件（swapfile）或在可执行映像中的定位。
一个进程访问一个无效页表项时，处理器产生一个陷入并报告一个页错误，它描述了页错误发生的虚地址和访问类型，这些类型通过页的错误码error_code中的前3位来判别，具体如下：
* bit 0 == 0，则错误由访问一个不存在的页引起的，否则由无效的访问权引起
* bit 1 == 0，则错误由读访问或执行访问所引起，否则由写访问引起
* bit 2 == 0，则错误发生在处理器处于内核态，否则发生在处理器处于用户态

页错误的线性地址被存于CR2寄存器，操作系统必须在vm_area_struct中找到页错误发生时页的虚拟地址（通过红黑树），通过do_page_fault()中的一部分代码说明：
```
/* CR2 中包含有最新的页错误发生时的虚拟地址*/
__asm__（"movl %%cr2,%0":"=r" （address））;
vma = find_vma（current, address）;
```
如果没找到，则说明访问了非法虚地址，Linux会发信号中止进程。否则就检查页错误类型，如果是非法类型同样会发送信号终止进程（比如越界错误、段权限错误等）。
## 进程地址空间中的缺页异常处理
对有效的虚拟地址，如果是缺页错误，Linux必须区分页所在的位置，即判断页是在交换文件中，还是在可执行映像中。为此，Linux通过页表项中的信息区分页所在的位置。如果该页的页表项无效但非空，则说明该页处于交换文件中，操作系统要从交换文件装入页。对于有效的虚拟地址address，do_page_fault()将其转到good_area标号处的语句执行：
```
good_area:
write = 0;
if （error_code & 2） { /* 写访问 */
if （!（vma->vm_flags & VM_WRITE））
goto bad_area;
write++;
} else /* 读访问 */
if （error_code & 1 ||
!（vma->vm_flags & （VM_READ | VM_EXEC）））
goto bad_area;
```
两个if分别代表错误由写访问引起、由读或执行访问引起。
如果虚拟区的访问权限与引起错误的访问类型相匹配，则调用handle_mm_fault()函数，如果成功地给进程分配一个页面则返回1；否则返回一个适当的错误码，以便do_page_fault()函数可以给进程发送SIGBUS信号。
handle_mm_fault()函数首先检查用来映射address的页中间目录和页表是否存在。即使address属于进程的地址空间，但其页表可能还未分配，因此首先执行分配页目录和页表。
然后，pgd_offset()宏计算出address所在页所在页目录中的目录指针。如果有中间目录，调用pmd_alloc()函数分配一个新的中间目录。然后，如果需要，调用pte_alloc()函数分配一个新的页表。如果两步都成功，pte变量所指向的页表表项就是引用address的表项。然后调用handle_pte_fault()函数检查address地址所对应的页表表项（该函数决定怎样给进程分配一个新的页面）。
如果被访问的页不存在，即还未存放在任何一个页面中，则内核分配一个新的页面并初始化。（请求调页）
如果存在但为只读，即已经被存放在页面中，则内核分配一个新页面并把旧页面的数据拷贝到新页面。（写时复制）
## 请求调页
这是一种动态内存分配技术，它把页面的分配推迟到不能再推迟为止，也就是一直推迟到进程要访问的页不在物理内存时为止，由此引起一个缺页错误。由于程序的局部性原理，它能增加系统中的空闲页面的平均数，从而更好地利用空间内存，同时它也能从整体上使系统有更大吞吐量。
但请求调页会带来系统额外的开销。，其引发的每个“缺页”错误必须由内核处理，这将浪费CPU的周期。
## 写时复制
写时复制的思想为：父进程和子进程共享页面而不是复制页面。因为复制页面需要做到以下操作：
* 为子进程页表分配页面
* 为子进程页分配页面
* 初始化子进程页表
* 把父进程页复制到子进程相应的页中

这样会涉及许多内存访问，消耗许多CPU周期。
但共享页面后，页面不能被修改。这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然为写保护的：当其他进程试图写入时，检查该进程是不是页面的唯一属主，否则不可写。
## 说明
* Linux通过fork()建立进程，进程初始时只有一个页目录和一页左右的可执行页，因此缺页异常会经常发生。
* 虚拟地址映射到物理地址只有在请页时才完成，这时要建立页表和更新页表。
* 在处理页故障的过程中，因为要涉及磁盘访问等操作，这样会耗时，因此操作系统会选择另外一个进程进入执行状态，即进行新一轮调度。

